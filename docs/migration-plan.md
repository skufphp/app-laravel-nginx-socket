## Пошаговый план (так, чтобы «не сломать пока всё работает»)

Ниже — последовательность, в которой мы **минимально рискуем**, постоянно можем откатиться, и в каждый момент понимаем, что именно изменилось.

---

## 0) Подготовка и страховка (обязательно)

1. **Зафиксировать текущий “working state”**
    - Убедиться, что текущий `docker-compose.yml` поднимается и приложение работает.
    - Прогнать базовые проверки (хотя бы homepage + health/laravel route).
2. **Сделать точку отката**
    - Отдельная ветка (или тег) под эту миграцию.
3. **Определить “истину” запуска**
    - Договориться, что дальше мы используем **Compose merge**:
        - Dev: `docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build`
        - Prod/CI: `docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d`
    - Это ключевое: **база + оверлеи**, а не два независимых compose-файла.

---

## 1) Инвентаризация: какие сервисы и связи должны остаться неизменными

Цель шага — выписать, что нельзя поломать:

- Какие сервисы есть сейчас (php, nginx, db, redis, pgadmin и т.д.).
- Какие у них зависимости:
    - nginx → php (unix socket)
    - php → db
- Какие volume’ы критичны (например, socket-директория, код приложения, persistent data БД).
- Какие порты реально нужны **только в dev** (80/5173/8080 и т.п.).

Результат: маленький чек-лист, по которому мы будем сверять каждый шаг.

---

## 2) Multistage `php.Dockerfile`: сделать аккуратно, без изменения поведения по умолчанию

Задача: **один Dockerfile**, но несколько `target`, чтобы:

- **dev** использовал stage без фронтенд-сборки (и потенциально с Xdebug),
- **prod** получал финальный рантайм **без node** (ассеты уже внутри `public/build`).

Порядок действий:

1. **Создать новые stages, но сохранить текущий stage как “dev-совместимый”**
    - Например:
        - `php-base` (то, что сейчас делает ваш PHP-образ)
        - `frontend-build` (node stage, собирает `public/build`)
        - `production` (на базе `php-base`, копирует `public/build` из `frontend-build`)
2. **Важно: ничего не менять в runtime-поведении dev**
    - `CMD`, `WORKDIR`, сокет, права — как сейчас.
3. **Добавить параметры сборки**
    - `--target php-base` для dev
    - `--target production` для prod/CI
4. **Проверка**
    - Собрать dev target: `docker build --target php-base ...`
    - Собрать prod target: `docker build --target production ...`
    - Убедиться, что prod-образ не тащит node (по составу слоёв/пакетов).

---

## 3) Разделение Compose на “base + dev overlay” без дублирования

### 3.1. Принцип разбиения (чтобы файлы “дополняли”, а не переписывали)

**`docker-compose.yml` (base, общий):**
- Содержит:
    - `services` с общей конфигурацией (build/image, env_file, networks, depends_on, healthcheck, volumes *только если это общие named volumes*).
- Не содержит (или почти не содержит):
    - `ports:` (почти всегда dev-only)
    - bind-mount проекта `./:/var/www/...` (это dev-only)
    - dev-only сервисы (vite/node, pgadmin, mailhog и т.п. — по желанию)

**`docker-compose.dev.yml` (overlay для разработки):**
- Добавляет:
    - `ports` наружу
    - bind mounts с кодом
    - node-сервис для HMR (если нужен)
    - named volume под `node_modules`
    - dev-override команд/target’ов сборки (например `build.target: php-base`)
- Может точечно **переписать** то, что иначе нельзя (например `command`, `target`, `environment`), но это исключение.

### 3.2. Пошагово, чтобы не сломать

1. **Скопировать текущий `docker-compose.yml` в “base-версию”**
2. **Сразу добавить второй файл `docker-compose.dev.yml`**
3. **Переносить настройки в dev-файл “маленькими порциями”**
    - Сначала вынести только `ports`
    - Проверить запуск
    - Потом вынести bind mounts
    - Проверить запуск
    - Потом добавить node-сервис (если нужен)
    - Проверить HMR
4. **На каждом мини-шаге проверка**
    - `docker compose -f docker-compose.yml -f docker-compose.dev.yml config`  
      Это покажет итоговый merged YAML и поможет увидеть, что где-то случайно перетёрлось.

---

## 4) `docker-compose.prod.yml`: “CI/CD-friendly” оверлей (минимальный и чистый)

Задача: прод должен работать как **деплой готовых образов**, а не как “build на сервере”.

### Принцип
- `docker-compose.yml` остаётся общим (сеть, общие volumes, возможно nginx/php сервисы как шаблон).
- `docker-compose.prod.yml`:
    - **подставляет `image: ${CI_REGISTRY_IMAGE}:${IMAGE_TAG}`** (или похожие переменные)
    - включает `restart: unless-stopped`
    - (опционально) публикует нужные порты (если это реально часть прод-рантайма)
    - (опционально) добавляет labels/traefik/ingress-настройки — если у вас так принято

### Пошагово
1. Оставить прод-файл максимально коротким: только то, что **обязано отличаться** от базы.
2. Никаких bind mounts кода в prod.
3. Проверка: `docker compose -f docker-compose.yml -f docker-compose.prod.yml config` и взглядом убедиться, что:
    - нет dev-томов
    - нет node
    - используется `image`, а не `build` (если так задумано под CI/CD)

---

## 5) Закрепить “boilerplate-правило” под ваши типы стеков (чтобы дальше масштабировать)

Чтобы этот шаблон был переиспользуемым под Blade/Livewire/Inertia/Nuxt (static/SPA), фиксируем правило:

- **Prod всегда multistage** (или CI build ассетов → копирование в prod image).
- **Dev — отдельный node-контейнер**, если нужен HMR.
- Node **никогда** не живёт в прод-рантайме, кроме будущего отдельного boilerplate под **Nuxt SSR** (там prod node-контейнер обязателен).

Практически это означает:
- В `docker-compose.dev.yml` node-сервис можно держать **опциональным** (профилем или комментируемым блоком), но архитектурно он всегда “рядом”, а не в PHP-образе.

---

## 6) Финальные проверки (перед тем как считать задачу выполненной)

1. **Dev**
    - `docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build`
    - Laravel открывается
    - PHP-FPM ↔ nginx через сокет работает
    - (если есть) HMR работает
2. **Prod (локальная имитация)**
    - Собрать prod image `--target production`
    - `docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d`
    - Проверить, что ассеты берутся из `public/build`, а `public/hot` не нужен
3. **Отсутствие дублирования**
    - Просмотреть итоговый merged config для dev/prod и убедиться, что оверлеи добавляют, а не копируют блоки целиком.

---

## Вопрос, который лучше уточнить до начала правок (1 штука, чтобы не переделывать)
Какой у вас сейчас “источник правды” в dev: **всегда нужен Vite HMR** (то есть node обязателен), или это опционально (Blade/Livewire иногда без HMR)?

Если ответишь — я под этот вариант предложу конкретную структуру сервисов (какие в base, какие в dev) и порядок переноса пункт-в-пункт.